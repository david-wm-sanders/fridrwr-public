"""Defines stuff for the FRIDARE patching system."""
import dataclasses

import frida
import jinja2

from loguru import logger

from . import jinja_fridajs_env
# from . import jinja_fridajs_env, FAsyncSession
# from .session import FAsyncSession
from .script import FAsyncScript


@dataclasses.dataclass
class PatchVarSpec:
    """Defines a dataclass to hold a patch variable specification."""

    name: str
    type: str
    size: int
    default: str


class FAsyncPatcherScript(FAsyncScript):
    """Extends FAsyncScript to wrap a script generated by a patch builder."""

    def __init__(self, name: str, source_js: str, script: frida.core.Script):
        """Initialise a FAsyncPatcherScript."""
        super().__init__(name, source_js, script)
        self._applied = False

    @property
    def applied(self) -> bool:
        """Return whether the patch is currently applied."""
        return self._applied

    def __str__(self):
        """Return str(self: FAsyncPatcherScript)."""
        return f"FAsyncPatcherScript({self.name=} [loaded:{self.loaded}, applied:{self.applied}]"

    # TODO: should wrap the _script.export.{apply,clear} as partial function and then trio.run_in_thread
    async def apply(self):
        """Apply the patch, if not already applied."""
        if not self._applied:
            logger.debug(f"Applying '{self.name}' patch...")
            self._script.exports.apply()
            self._applied = True
        else:
            logger.error(f"Patch '{self.name}' is already applied!")

    async def clear(self):
        """Clear the patch, if applied."""
        if self._applied:
            self._script.exports.clear()
            self._applied = False
        else:
            logger.error(f"Can't clear patch '{self.name}' when it is not applied!")


class PatchBuilder:
    """Generates patches from templates using jinja2."""

    def __init__(self):
        """Discover patch templates om fridajs jinja env."""
        self._jmp_patch_template: jinja2.Template = jinja_fridajs_env.get_template("jmp_patch.js")
        self._nop_patch_template: jinja2.Template = jinja_fridajs_env.get_template("nop_patch.js")

    # TODO: no point async unless rendering can be pushed to another thread
    # async def create_jmp_patch_js(self, name: str, module_name: str, target_pattern: str,
    def gen_jmp_patch_js(self, name: str, module_name: str, target_pattern: str,
                         vars_spec: list[PatchVarSpec], relocate_target: bool,
                         patch_mem_size: int, return_offset: int,
                         cw_patch_func: str):
        """Build a jmp patch script."""
        _script_name = f"{name}_jmp_patch.js"
        logger.debug(f"Creating jmp patch: {name=} [{module_name=}] "
                     f"^ {target_pattern=}\n"
                     f"{vars_spec=}, {relocate_target=}, {patch_mem_size=}, {return_offset=}\n"
                     f"cw_patch_func={cw_patch_func}")

        _vars = [f"{{name: '{v.name}', type: '{v.type}', size: {v.size }, default: {v.default} }}" for v in vars_spec]
        vars_spec_list = f"[{', '.join(_vars)}]"
        rt = "true" if relocate_target else "false"
        jmp_patch_js = self._jmp_patch_template.render(name=name, module_name=module_name,
                                                       target_pattern=target_pattern,
                                                       vars_spec=vars_spec_list,
                                                       relocate_target=rt,
                                                       patch_mem_size=patch_mem_size,
                                                       return_offset=return_offset,
                                                       cw_patch_func=cw_patch_func)
        return _script_name, jmp_patch_js

    def gen_nop_patch_js(self, name: str, module_name: str, target_pattern: str,
                         nop_offset: int, nop_length: int):
        """Build a nop patch script."""
        _script_name = f"{name}_nop_patch.js"
        logger.debug(f"Creating nop patch: {name=} [{module_name}] "
                     f"^ {target_pattern=} [{nop_offset=}, {nop_length=}")

        nop_patch_js = self._nop_patch_template.render(name=name, module_name=module_name,
                                                       target_pattern=target_pattern,
                                                       nop_offset=nop_offset, nop_length=nop_length)

        return _script_name, nop_patch_js
